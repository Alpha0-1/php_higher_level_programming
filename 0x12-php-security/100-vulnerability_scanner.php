<?php
/**
 * Basic security vulnerability scanner
 * Checks for common security issues in PHP applications
 */

class VulnerabilityScanner {
    private $scanResults = [];
    
    public function scanDirectory($directory) {
        $iterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($directory));
        
        foreach ($iterator as $file) {
            if ($file->isDir() || $file->getExtension() !== 'php') {
                continue;
            }
            
            $this->scanFile($file->getPathname());
        }
        
        return $this->scanResults;
    }
    
    protected function scanFile($filePath) {
        $content = file_get_contents($filePath);
        $lines = explode("\n", $content);
        
        $checks = [
            'SQL Injection' => [
                '/\b(mysql_|mysqli_)?query\s*\([^\)]*\$/', // Dynamic variables in queries
                '/\$_((GET|POST|REQUEST|COOKIE|SERVER)\[.*\])\s*\)?\s*;/', // Direct superglobal usage
            ],
            'XSS Vulnerability' => [
                '/echo\s+\$_(GET|POST|REQUEST|COOKIE|SERVER)\[.*\]/', // Direct output of user input
                '/<\?=\s*\$_(GET|POST|REQUEST|COOKIE|SERVER)\[.*\]\?>/', // Short tags with user input
            ],
            'File Inclusion' => [
                '/include\s*\(?\s*\$_(GET|POST|REQUEST|COOKIE|SERVER)\[.*\]/', // Dynamic includes
                '/require\s*\(?\s*\$_(GET|POST|REQUEST|COOKIE|SERVER)\[.*\]/',
            ],
            'Unescaped Output' => [
                '/<\?php\s+echo\s+[^\s].*?\?>/i', // Echo without escaping
            ],
        ];
        
        foreach ($checks as $vulnName => $patterns) {
            foreach ($patterns as $pattern) {
                if (preg_match($pattern, $content)) {
                    $matches = [];
                    preg_match_all($pattern, $content, $matches, PREG_OFFSET_CAPTURE);
                    
                    foreach ($matches[0] as $match) {
                        $lineNumber = $this->getLineNumber($content, $match[1]);
                        $this->addResult(
                            $filePath,
                            $lineNumber,
                            $vulnName,
                            trim($lines[$lineNumber - 1])
                        );
                    }
                }
            }
        }
    }
    
    protected function addResult($file, $line, $vulnerability, $codeSnippet) {
        $this->scanResults[] = [
            'file' => $file,
            'line' => $line,
            'vulnerability' => $vulnerability,
            'code' => $codeSnippet
        ];
    }
    
    protected function getLineNumber($content, $offset) {
        return substr_count(substr($content, 0, $offset), "\n") + 1;
    }
}

// Example usage
$scanner = new VulnerabilityScanner();
$results = $scanner->scanDirectory(__DIR__);

echo "<h2>Security Scan Results</h2>";
echo "<table border='1'>";
echo "<tr><th>File</th><th>Line</th><th>Vulnerability</th><th>Code</th></tr>";

foreach ($results as $result) {
    echo "<tr>";
    echo "<td>" . htmlspecialchars($result['file']) . "</td>";
    echo "<td>" . $result['line'] . "</td>";
    echo "<td>" . htmlspecialchars($result['vulnerability']) . "</td>";
    echo "<td><code>" . htmlspecialchars($result['code']) . "</code></td>";
    echo "</tr>";
}

echo "</table>";

// Note: This is a basic scanner. For production use consider:
// - PHPStan with security rules
// - Psalm with security audit
// - RIPS static analysis tool
// - Commercial tools like SonarQube, Checkmarx, etc.
?>
